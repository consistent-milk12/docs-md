---
source: tests/integration_tests.rs
assertion_line: 62
expression: capture.to_snapshot_string()
---
=== error.md ===
# Module `error`

Error types for docs-md.

This module defines all errors that can occur during documentation generation.
Errors use the `miette` crate for enhanced diagnostics, providing:
- Human-readable error messages
- Diagnostic codes for programmatic handling
- Helpful suggestions for resolution

# Error Categories

- **I/O Errors** (`FileRead`, `CreateDir`, `FileWrite`): File system operations
- **Parse Errors** (`JsonParse`): Invalid or malformed rustdoc JSON
- **Lookup Errors** (`ItemNotFound`): Missing items in the documentation index

## Enums

### `Error`

```rust
enum Error {
    FileRead(StdIO::Error),
    JsonParse(SJSON::Error),
    CreateDir(StdIO::Error),
    FileWrite(StdIO::Error),
    ItemNotFound(String),
    InvalidDirectory(String),
    NoJsonFiles(std::path::PathBuf),
    DuplicateCrate(String),
    NoCrateName(std::path::PathBuf),
    ProgressBarTemplate(indicatif::style::TemplateError),
}
```

Errors that can occur during documentation generation.

Each variant includes:
- A human-readable error message
- A diagnostic code (e.g., `docs_md::io::read`)
- Optional help text for resolution
- The underlying source error (where applicable)

#### Variants

- **`FileRead`**

  Failed to read a file from disk.
  
  This typically occurs when:
  - The file doesn't exist
  - The process lacks read permissions
  - The path is invalid

- **`JsonParse`**

  Failed to parse the rustdoc JSON file.
  
  This can happen when:
  - The file is not valid JSON
  - The JSON schema doesn't match `rustdoc-types` expectations
  - The file is from an incompatible rustdoc version

- **`CreateDir`**

  Failed to create the output directory.
  
  This typically occurs when:
  - The parent directory doesn't exist
  - The process lacks write permissions
  - The path is invalid or too long

- **`FileWrite`**

  Failed to write a markdown file.
  
  This typically occurs when:
  - The output directory is not writable
  - The disk is full
  - The file is locked by another process

- **`ItemNotFound`**

  An item ID was not found in the crate's index.
  
  The rustdoc JSON index should contain all referenced items.
  This error indicates data inconsistency, possibly from:
  - Corrupted JSON
  - Incompatible rustdoc-types version
  - Items removed during filtering
  
  The string contains the ID that was not found.

- **`InvalidDirectory`**

  The specified directory path is invalid or inaccessible.
  
  This typically occurs when:
  - The path doesn't exist
  - The path is a file, not a directory
  - The process lacks read permissions

- **`NoJsonFiles`**

  No rustdoc JSON files were found in the specified directory.
  
  The directory should contain `.json` files generated by rustdoc
  with the `--output-format json` flag.

- **`DuplicateCrate`**

  Multiple crates with the same name were found.
  
  Each JSON file should represent a unique crate. This error
  indicates duplicate crate names in the input directory.

- **`NoCrateName`**

  Could not determine the crate name from a JSON file.
  
  The rustdoc JSON format should include a root item with
  the crate name. This error indicates a malformed file.

- **`ProgressBarTemplate`**

  Failed to create a progress bar with the given template.
  
  This indicates an invalid progress bar template string.
  Since templates are compile-time constants, this error
  typically indicates a programming error.

#### Trait Implementations

##### `impl Debug for Error`

- `fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<'_>) -> $crate::fmt::Result`

##### `impl Diagnostic for Error`

- `fn code(self: &Self) -> std::option::Option<std::boxed::Box<dyn std::fmt::Display>>`

- `fn help(self: &Self) -> std::option::Option<std::boxed::Box<dyn std::fmt::Display>>`

##### `impl Display for Error`

- `fn fmt(self: &Self, __formatter: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result`

##### `impl Error for Error`

- `fn source(self: &Self) -> ::core::option::Option<&dyn ::thiserror::__private17::Error>`

##### `impl<T> IntoEither for Error`

##### `impl<D> OwoColorize for Error`

##### `impl<T> Pointable for Error`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`

##### `impl<T> ToString for Error`

- `fn to_string(self: &Self) -> String`


=== generator.md ===
# Module `generator`

Markdown documentation generator for rustdoc JSON.

This is the core module that transforms rustdoc JSON data into markdown files.
It handles the complete generation pipeline: traversing modules, rendering
different item types, and creating cross-reference links.

# Architecture

The generation process follows these steps:

1. **Setup**: Create output directory, build path and impl maps
2. **Link Registry**: Build a registry mapping item IDs to file paths
3. **Generation**: Recursively traverse modules and write markdown files

# Module Structure

- [`context`](generator__context.md) - Shared state for generation (crate data, maps, config)
- [`module`](generator__module.md) - Module-level markdown rendering
- [`items`](generator__items.md) - Individual item rendering (structs, enums, traits, etc.)
- [`impls`](generator__impls.md) - Implementation block rendering
- [`flat`](generator__flat.md) - Flat output format generator
- [`nested`](generator__nested.md) - Nested output format generator

# Output Formats

Two output formats are supported:

- **Flat**: All files in one directory (`module.md`, `parent__child.md`)
- **Nested**: Directory hierarchy (`module/index.md`, `parent/child/index.md`)

# Usage

```ignore
use docs_md::generator::Generator;

let generator = Generator::new(&krate, &args)?;
generator.generate()?;
```

## Modules

- [`breadcrumbs`](generator__breadcrumbs.md) - Breadcrumb navigation generation for nested module pages.
- [`doc_links`](generator__doc_links.md) - Intra-doc link processing for documentation generation.
- [`impls`](generator__impls.md) - Implementation block rendering for documentation generation.
- [`module`](generator__module.md) - Module markdown rendering for documentation generation.
- [`render_shared`](generator__render_shared.md) - Shared rendering functions for documentation generation.

## Structs

### `Generator<'a>`

```rust
struct Generator<'a> {
    ctx: GeneratorContext<'a>,
    args: &'a crate::Args,
    root_item: &'a rustdoc_types::Item,
}
```

Main documentation generator.

This struct orchestrates the entire documentation generation process,
coordinating between the context, format-specific generators, and
progress reporting.

# Example

```ignore
let generator = Generator::new(&krate, &args)?;
generator.generate()?;
```

#### Fields

- **`ctx`**: `GeneratorContext<'a>`

  Shared context containing crate data, maps, and configuration.

- **`args`**: `&'a crate::Args`

  CLI arguments containing output path and format options.

- **`root_item`**: `&'a rustdoc_types::Item`

  The root module item of the crate.

#### Implementations

- `fn new(krate: &'a Crate, args: &'a Args) -> Result<Self, Error>` — [`Args`](index.md), [`Error`](error.md)

  Create a new generator for the given crate and arguments.

- `fn generate(self: &Self) -> Result<(), Error>` — [`Error`](error.md)

  Generate markdown documentation.

- `fn create_progress_bar(total: usize) -> Result<ProgressBar, Error>` — [`Error`](error.md)

  Create a progress bar for user feedback.

- `fn generate_to_capture(krate: &Crate, format: CliOutputFormat, include_private: bool) -> Result<MarkdownCapture, Error>` — [`CliOutputFormat`](index.md), [`MarkdownCapture`](generator__capture.md), [`Error`](error.md)

  Generate documentation to memory instead of disk.

- `fn generate_flat_to_capture(ctx: &GeneratorContext<'_>, root: &Item, capture: &mut MarkdownCapture) -> Result<(), Error>` — [`GeneratorContext`](generator__context.md), [`MarkdownCapture`](generator__capture.md), [`Error`](error.md)

  Generate flat structure to capture.

- `fn generate_flat_recursive_capture(ctx: &GeneratorContext<'_>, item: &Item, prefix: &str, capture: &mut MarkdownCapture) -> Result<(), Error>` — [`GeneratorContext`](generator__context.md), [`MarkdownCapture`](generator__capture.md), [`Error`](error.md)

  Recursive flat generation to capture.

- `fn generate_nested_to_capture(ctx: &GeneratorContext<'_>, root: &Item, path_prefix: &str, capture: &mut MarkdownCapture) -> Result<(), Error>` — [`GeneratorContext`](generator__context.md), [`MarkdownCapture`](generator__capture.md), [`Error`](error.md)

  Generate nested structure to capture.

- `fn run(krate: &'a Crate, args: &'a Args) -> Result<(), Error>` — [`Args`](index.md), [`Error`](error.md)

  Convenience method to generate documentation in one call.

#### Trait Implementations

##### `impl<T> IntoEither for Generator<'a>`

##### `impl<D> OwoColorize for Generator<'a>`

##### `impl<T> Pointable for Generator<'a>`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`


=== generator__breadcrumbs.md ===
# Module `breadcrumbs`

Breadcrumb navigation generation for nested module pages.

This module provides [`BreadcrumbGenerator`](#breadcrumbgenerator) which creates navigation
links showing the path from crate root to the current module.

## Structs

### `BreadcrumbGenerator<'a>`

```rust
struct BreadcrumbGenerator<'a> {
    module_path: &'a [String],
    crate_name: &'a str,
}
```

Generates breadcrumb navigation for nested module pages.

Creates a navigation line showing the path from the crate root to
the current module, with each segment being a clickable link.

#### Fields

- **`module_path`**: `&'a [String]`

  The module path segments (e.g., `["error", "types"]`).

- **`crate_name`**: `&'a str`

  The name of the crate for the root link.

#### Implementations

- `const fn new(module_path: &'a [String], crate_name: &'a str) -> Self`

  Create a new breadcrumb generator.

- `fn generate(self: &Self) -> String`

  Generate breadcrumb navigation markdown.

#### Trait Implementations

##### `impl<T> IntoEither for BreadcrumbGenerator<'a>`

##### `impl<D> OwoColorize for BreadcrumbGenerator<'a>`

##### `impl<T> Pointable for BreadcrumbGenerator<'a>`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`


=== generator__doc_links.md ===
# Module `doc_links`

Intra-doc link processing for documentation generation.

This module provides [`DocLinkProcessor`](#doclinkprocessor) which transforms rustdoc
intra-doc link syntax into proper markdown links.

# Processing Pipeline
The processor applies transformations in this order:
1. Strip markdown reference definitions
2. Unhide rustdoc hidden lines in code blocks
3. Process reference-style links `[text][`ref`]`
4. Process path reference links ``text``
5. Process method links `[Type::method]`
6. Process backtick links `[`Name`]`
7. Process plain links `[name]`
8. Convert HTML-style rustdoc links
9. Clean up blank lines

Links inside code blocks are protected from transformation.

## Structs

### `DocLinkProcessor<'a>`

```rust
struct DocLinkProcessor<'a> {
    krate: &'a rustdoc_types::Crate,
    link_registry: &'a crate::linker::LinkRegistry,
    current_file: &'a str,
    path_name_index: std::collections::HashMap<&'a str, Vec<rustdoc_types::Id>>,
}
```

Processes doc comments to resolve intra-doc links to markdown links.

Rustdoc JSON includes a `links` field on each Item that maps intra-doc
link text to item IDs. This processor uses that map along with the
`LinkRegistry` to convert these to relative markdown links.

# Supported Patterns

- `` [`Name`] `` - Backtick code links (most common)
- `` [`Item`](https://docs.rs/rustdoc_types/latest/rustdoc_types/struct.Item.html) `` - Qualified path links
- `` [`Type::method`] `` - Method/associated item links
- `[name]` - Plain identifier links
- `[text][`ref`]` - Reference-style links
- ``text`` - Path reference links

# External Crate Links

Items from external crates are linked to docs.rs when possible.

# Code Block Protection

Links inside fenced code blocks are not processed.

#### Fields

- **`krate`**: `&'a rustdoc_types::Crate`

  The crate being documented (for looking up items).

- **`link_registry`**: `&'a crate::linker::LinkRegistry`

  Registry mapping IDs to file paths.

- **`current_file`**: `&'a str`

  The current file path (for relative link calculation).

- **`path_name_index`**: `std::collections::HashMap<&'a str, Vec<rustdoc_types::Id>>`

  Index mapping item names to their IDs for fast lookup.
  Built from `krate.paths` at construction time.

#### Implementations

- `fn new(krate: &'a Crate, link_registry: &'a LinkRegistry, current_file: &'a str) -> Self` — [`LinkRegistry`](linker.md)

  Create a new processor for the given context.

- `fn process(self: &Self, docs: &str, item_links: &HashMap<String, Id>) -> String`

  Process a doc string and resolve all intra-doc links.

- `fn process_links_protected(self: &Self, docs: &str, item_links: &HashMap<String, Id>) -> String`

  Process links while protecting code block contents.

- `fn process_line(self: &Self, line: &str, item_links: &HashMap<String, Id>) -> String`

  Process a single line for all link types.

- `fn process_reference_links(self: &Self, text: &str, item_links: &HashMap<String, Id>) -> String`

  Process reference-style links `[display text](https://docs.rs/regex_syntax/latest/regex_syntax/ast/struct.Span.html)`.

- `fn process_path_reference_links(self: &Self, text: &str, item_links: &HashMap<String, Id>) -> String`

  Process path reference links `[text](https://docs.rs/rustdoc_types/latest/rustdoc_types/struct.Item.html)`.

- `fn process_method_links(self: &Self, text: &str, item_links: &HashMap<String, Id>) -> String`

  Process method links `[``Type::method``]`.

- `fn process_backtick_links(self: &Self, text: &str, item_links: &HashMap<String, Id>) -> String`

  Process backtick links `[`Name`]`.

- `fn process_plain_links(self: &Self, text: &str, item_links: &HashMap<String, Id>) -> String`

  Process plain links `[name]`.

- `fn process_html_links_with_context(self: &Self, text: &str, item_links: &HashMap<String, Id>) -> String`

  Process HTML-style rustdoc links with context awareness.

- `fn resolve_html_link_to_url(self: &Self, item_name: &str, item_kind: &str, item_links: &HashMap<String, Id>) -> Option<String>`

  Try to resolve an HTML-style link to a proper URL.

- `fn kind_matches(html_kind: &str, item_kind: ItemKind) -> bool`

  Check if the HTML link kind matches the rustdoc item kind.

- `fn clean_blank_lines(docs: &str) -> String`

  Clean up multiple consecutive blank lines.

- `fn resolve_to_url(self: &Self, link_text: &str, item_links: &HashMap<String, Id>) -> Option<String>`

  Resolve a link reference to a URL.

- `fn get_url_for_id(self: &Self, id: Id) -> Option<String>`

  Get the URL for an ID (local or docs.rs).

- `fn get_docs_rs_url(path_info: &rustdoc_types::ItemSummary) -> Option<String>`

  Get docs.rs URL for an external crate item.

- `fn resolve_method_link(self: &Self, type_name: &str, method_name: &str, item_links: &HashMap<String, Id>) -> Option<String>`

  Resolve a method link to a markdown link (without method anchor).

- `fn resolve_link(self: &Self, link_text: &str, item_links: &HashMap<String, Id>) -> String`

  Try to resolve link text to a markdown link.

- `fn create_link_for_id(self: &Self, id: Id, display_name: &str) -> Option<String>`

  Create a markdown link for an ID.

- `fn create_docs_rs_link(path_info: &rustdoc_types::ItemSummary, display_name: &str) -> Option<String>`

  Create a docs.rs link for an external crate item.

#### Trait Implementations

##### `impl<T> IntoEither for DocLinkProcessor<'a>`

##### `impl<D> OwoColorize for DocLinkProcessor<'a>`

##### `impl<T> Pointable for DocLinkProcessor<'a>`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`

## Functions

### `convert_html_links`

```rust
fn convert_html_links(docs: &str) -> String
```

Convert HTML-style rustdoc links to markdown anchors.

Transforms links like:
- `(https://docs.rs/unit_prefix/latest/unit_prefix/enum.NumberPrefix.html)` -> `(#numberprefix)`
- `` -> removes the link (methods don't have anchors)

This is useful for multi-crate documentation where the full processor
context may not be available.

### `strip_duplicate_title`

```rust
fn strip_duplicate_title<'a>(docs: &'a str, item_name: &str) -> &'a str
```

Strip duplicate title from documentation.

Some crate/module docs start with `# title` which duplicates the generated
`# Crate 'name'` or `# Module 'name'` heading.

# Arguments

* `docs` - The documentation string to process
* `item_name` - The name of the crate or module being documented

# Returns

The docs with the leading title removed if it matches the item name,
otherwise the original docs unchanged.

### `strip_reference_definitions`

```rust
fn strip_reference_definitions(docs: &str) -> String
```

Strip markdown reference definition lines.

Removes lines like `[`Name`]: path::to::item` which are no longer needed
after intra-doc links are processed.

### `unhide_code_lines`

```rust
fn unhide_code_lines(docs: &str) -> String
```

Unhide rustdoc hidden lines in code blocks and add language identifiers.

This function performs two transformations on code blocks:
1. Lines starting with `# ` inside code blocks are hidden in rustdoc
   but compiled. We remove the prefix to show the full example.
2. Bare code fences (` ``` `) are converted to ` ```rust ` since doc
   examples are Rust code.

### `convert_path_reference_links`

```rust
fn convert_path_reference_links(docs: &str) -> String
```

Convert path-style reference links to inline code.

Transforms: `[``ProgressTracker``](https://docs.rs/indicatif/latest/indicatif/style/trait.ProgressTracker.html)`
Into: `` `ProgressTracker` ``

Without full link resolution context, we can't create valid anchors,
so we preserve the display text as inline code.


=== generator__impls.md ===
# Module `impls`

Implementation block rendering for documentation generation.

This module provides the [`ImplRenderer`](#implrenderer) struct which handles rendering
impl blocks (both inherent and trait implementations) to markdown format.

## Structs

### `ImplRenderer<'a>`

```rust
struct ImplRenderer<'a> {
    ctx: &'a dyn RenderContext,
    current_file: &'a str,
    type_renderer: crate::types::TypeRenderer<'a>,
}
```

Renders impl blocks to markdown.

This struct handles:
- Inherent implementations (`impl MyType { ... }`)
- Trait implementations (`impl Trait for MyType { ... }`)
- Method signatures within impl blocks
- Associated types and constants

The renderer is generic over [`RenderContext`](generator__context.md), allowing it to work with
both single-crate (`GeneratorContext`) and multi-crate (`SingleCrateView`) modes.

#### Fields

- **`ctx`**: `&'a dyn RenderContext`

  Reference to the render context (either single-crate or multi-crate).

- **`current_file`**: `&'a str`

  Path of the current file being generated (for relative link calculation).

- **`type_renderer`**: `crate::types::TypeRenderer<'a>`

  Cached type renderer to avoid repeated construction.

#### Implementations

- `fn new(ctx: &'a dyn RenderContext, current_file: &'a str) -> Self` — [`RenderContext`](generator__context.md)

  Create a new impl renderer with the given context.

- `fn process_docs(self: &Self, item: &Item) -> Option<String>`

  Process documentation string to resolve intra-doc links.

- `fn render_impl_blocks(self: &Self, md: &mut String, item_id: Id)`

  Render impl blocks for a given type.

- `fn render_trait_impl(self: &Self, md: &mut String, impl_block: &Impl)`

  Render a single trait implementation block.

- `fn render_impl_methods(self: &Self, md: &mut String, impl_block: &Impl)`

  Render the items (methods, constants, types) within an impl block.

- `fn render_generic_args_for_impl(self: &Self, args: &rustdoc_types::GenericArgs) -> String`

  Render generic arguments for impl block signatures.

#### Trait Implementations

##### `impl<T> IntoEither for ImplRenderer<'a>`

##### `impl<D> OwoColorize for ImplRenderer<'a>`

##### `impl<T> Pointable for ImplRenderer<'a>`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`

## Functions

### `is_blanket_impl`

```rust
fn is_blanket_impl(impl_block: &rustdoc_types::Impl) -> bool
```

Check if an impl block is for a blanket trait that should be filtered.

Returns `true` if the impl is for one of the commonly auto-derived traits
that add noise to documentation (From, Into, Any, Borrow, etc.).


=== generator__module.md ===
# Module `module`

Module markdown rendering for documentation generation.

This module provides the [`ModuleRenderer`](#modulerenderer) struct which handles rendering
a Rust module's documentation to markdown format, including all its items
organized by type.

## Structs

### `ModuleRenderer<'a>`

```rust
struct ModuleRenderer<'a> {
    ctx: &'a dyn RenderContext,
    current_file: &'a str,
    is_root: bool,
}
```

Renders a module to markdown.

This struct handles the complete rendering of a module's documentation page,
including:
- Title (Crate or Module heading)
- Module-level documentation
- Sections for each item type (Modules, Structs, Enums, etc.)

The renderer is generic over [`RenderContext`](generator__context.md), allowing it to work with
both single-crate (`GeneratorContext`) and multi-crate (`SingleCrateView`) modes.

#### Fields

- **`ctx`**: `&'a dyn RenderContext`

  Reference to the render context (either single-crate or multi-crate).

- **`current_file`**: `&'a str`

  Path of the current file being generated (for relative link calculation).

- **`is_root`**: `bool`

  Whether this is the crate root module.

#### Implementations

- `fn new(ctx: &'a dyn RenderContext, current_file: &'a str, is_root: bool) -> Self` — [`RenderContext`](generator__context.md)

  Create a new module renderer.

- `fn process_docs(self: &Self, item: &Item) -> Option<String>`

  Process documentation string to resolve intra-doc links.

- `fn render(self: &Self, item: &Item) -> String`

  Generate the complete markdown content for a module.

- `fn categorize_items(self: &Self, item_ids: &'a [Id]) -> CategorizedItems<'a>` — [`CategorizedItems`](#categorizeditems)

  Categorize module items by type for organized rendering.

- `fn render_all_sections(self: &Self, md: &mut String, items: &CategorizedItems<'_>)` — [`CategorizedItems`](#categorizeditems)

  Render all item sections in the standard order.

- `fn render_modules_section(self: &Self, md: &mut String, modules: &[(&Id, &Item)])`

  Render the Modules section with links to submodules.

- `fn render_structs_section(self: &Self, md: &mut String, structs: &[(&Id, &Item)])`

  Render the Structs section.

- `fn render_enums_section(self: &Self, md: &mut String, enums: &[(&Id, &Item)])`

  Render the Enums section.

- `fn render_traits_section(self: &Self, md: &mut String, traits: &[(&Id, &Item)])`

  Render the Traits section.

- `fn render_functions_section(self: &Self, md: &mut String, functions: &[&Item])`

  Render the Functions section.

- `fn render_macros_section(self: &Self, md: &mut String, macros: &[&Item])`

  Render the Macros section.

- `fn render_constants_section(self: &Self, md: &mut String, constants: &[&Item])`

  Render the Constants section.

- `fn render_type_aliases_section(self: &Self, md: &mut String, type_aliases: &[&Item])`

  Render the Type Aliases section.

#### Trait Implementations

##### `impl<T> IntoEither for ModuleRenderer<'a>`

##### `impl<D> OwoColorize for ModuleRenderer<'a>`

##### `impl<T> Pointable for ModuleRenderer<'a>`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`


=== generator__render_shared.md ===
# Module `render_shared`

Shared rendering functions for documentation generation.

This module contains standalone rendering functions that can be used by both
single-crate ([`ItemRenderer`](super::ItemRenderer)) and multi-crate
([`MultiCrateModuleRenderer`](crate::multi_crate::generator)) renderers.

These functions handle the core markdown generation logic without being tied
to a specific rendering context, avoiding code duplication between the two modes.

## Traits

### `DocsProcessor`

```rust
trait DocsProcessor { ... }
```

Check if a render context can resolve documentation.

This trait provides a unified way to process docs from different contexts.

#### Required Methods

- `fn process_item_docs(self: &Self, item: &Item) -> Option<String>`

  Process documentation for an item, resolving intra-doc links.

## Functions

### `render_struct_definition`

```rust
fn render_struct_definition(md: &mut String, name: &str, s: &rustdoc_types::Struct, krate: &rustdoc_types::Crate, type_renderer: &crate::types::TypeRenderer<'_>)
```

**Types:** [`TypeRenderer`](types.md)

Render a struct definition code block to markdown.

Produces a heading with the struct name and generics, followed by a Rust
code block showing the struct definition.

# Arguments

* `md` - Output markdown string
* `name` - The struct name (may differ from item.name for re-exports)
* `s` - The struct data from rustdoc
* `krate` - The crate containing field definitions
* `type_renderer` - Type renderer for generics and field types

### `render_struct_fields`

```rust
fn render_struct_fields<F>(md: &mut String, fields: &[rustdoc_types::Id], krate: &rustdoc_types::Crate, type_renderer: &crate::types::TypeRenderer<'_>, process_docs: F)
where
    F: Fn(&rustdoc_types::Item) -> Option<String>
```

**Types:** [`TypeRenderer`](types.md)

Render documented struct fields to markdown.

Produces a "Fields" section with each documented field as a bullet point
showing the field name, type, and documentation.

# Arguments

* `md` - Output markdown string
* `fields` - Field IDs from the struct
* `krate` - Crate containing field definitions
* `type_renderer` - Type renderer for field types
* `process_docs` - Closure to process documentation with intra-doc link resolution

### `render_enum_definition`

```rust
fn render_enum_definition(md: &mut String, name: &str, e: &rustdoc_types::Enum, krate: &rustdoc_types::Crate, type_renderer: &crate::types::TypeRenderer<'_>)
```

**Types:** [`TypeRenderer`](types.md)

Render an enum definition code block to markdown.

Produces a heading with the enum name and generics, followed by a Rust
code block showing the enum definition with all variants.

# Arguments

* `md` - Output markdown string
* `name` - The enum name (may differ from item.name for re-exports)
* `e` - The enum data from rustdoc
* `krate` - The crate containing variant definitions
* `type_renderer` - Type renderer for generics and variant types

### `render_enum_variant`

```rust
fn render_enum_variant(md: &mut String, variant: &rustdoc_types::Item, krate: &rustdoc_types::Crate, type_renderer: &crate::types::TypeRenderer<'_>)
```

**Types:** [`TypeRenderer`](types.md)

Render a single enum variant within the definition code block.

Handles all three variant kinds: plain, tuple, and struct variants.

### `render_enum_variants_docs`

```rust
fn render_enum_variants_docs<F>(md: &mut String, variants: &[rustdoc_types::Id], krate: &rustdoc_types::Crate, process_docs: F)
where
    F: Fn(&rustdoc_types::Item) -> Option<String>
```

Render documented enum variants to markdown.

Produces a "Variants" section with each documented variant as a bullet point.

# Arguments

* `md` - Output markdown string
* `variants` - Variant IDs from the enum
* `krate` - Crate containing variant definitions
* `process_docs` - Closure to process documentation with intra-doc link resolution

### `render_trait_definition`

```rust
fn render_trait_definition(md: &mut String, name: &str, t: &rustdoc_types::Trait, type_renderer: &crate::types::TypeRenderer<'_>)
```

**Types:** [`TypeRenderer`](types.md)

Render a trait definition code block to markdown.

Produces a heading with the trait name and generics, followed by a Rust
code block showing the trait signature with supertraits.

# Arguments

* `md` - Output markdown string
* `name` - The trait name
* `t` - The trait data from rustdoc
* `type_renderer` - Type renderer for generics and bounds

### `render_trait_item`

```rust
fn render_trait_item<F>(md: &mut String, item: &rustdoc_types::Item, type_renderer: &crate::types::TypeRenderer<'_>, process_docs: F)
where
    F: Fn(&rustdoc_types::Item) -> Option<String>
```

**Types:** [`TypeRenderer`](types.md)

Render a single trait item (method, associated type, or constant).

Each item is rendered as a bullet point with its signature in backticks.
For methods, the first line of documentation is included.

# Arguments

* `md` - Output markdown string
* `item` - The trait item (function, assoc type, or assoc const)
* `type_renderer` - Type renderer for types
* `process_docs` - Closure to process documentation with intra-doc link resolution

### `render_function_definition`

```rust
fn render_function_definition(md: &mut String, name: &str, f: &rustdoc_types::Function, type_renderer: &crate::types::TypeRenderer<'_>)
```

**Types:** [`TypeRenderer`](types.md)

Render a function definition to markdown.

Produces a heading with the function name, followed by a Rust code block
showing the full signature with modifiers (const, async, unsafe).

# Arguments

* `md` - Output markdown string
* `name` - The function name
* `f` - The function data from rustdoc
* `type_renderer` - Type renderer for parameter and return types

### `render_constant_definition`

```rust
fn render_constant_definition(md: &mut String, name: &str, type_: &rustdoc_types::Type, const_: &rustdoc_types::Constant, type_renderer: &crate::types::TypeRenderer<'_>)
```

**Types:** [`TypeRenderer`](types.md)

Render a constant definition to markdown.

Produces a heading with the constant name, followed by a Rust code block
showing `const NAME: Type = value;`.

# Arguments

* `md` - Output markdown string
* `name` - The constant name
* `type_` - The constant's type
* `const_` - The constant data including value
* `type_renderer` - Type renderer for the type

### `render_type_alias_definition`

```rust
fn render_type_alias_definition(md: &mut String, name: &str, ta: &rustdoc_types::TypeAlias, type_renderer: &crate::types::TypeRenderer<'_>)
```

**Types:** [`TypeRenderer`](types.md)

Render a type alias definition to markdown.

Produces a heading with the alias name and generics, followed by a Rust
code block showing `type Name<T> = TargetType;`.

# Arguments

* `md` - Output markdown string
* `name` - The type alias name
* `ta` - The type alias data from rustdoc
* `type_renderer` - Type renderer for generics and the aliased type

### `render_macro_heading`

```rust
fn render_macro_heading(md: &mut String, name: &str)
```

Render a macro definition to markdown.

Produces a heading with the macro name and `!` suffix.
Note: We don't show macro rules since rustdoc JSON doesn't provide them.

# Arguments

* `md` - Output markdown string
* `name` - The macro name

### `render_impl_items`

```rust
fn render_impl_items<F>(md: &mut String, impl_block: &rustdoc_types::Impl, krate: &rustdoc_types::Crate, type_renderer: &crate::types::TypeRenderer<'_>, process_docs: Option<F>)
where
    F: Fn(&rustdoc_types::Item) -> Option<String>
```

**Types:** [`TypeRenderer`](types.md)

Render the items within an impl block.

This renders all methods, associated constants, and associated types
within an impl block as bullet points.

# Arguments

* `md` - Output markdown string
* `impl_block` - The impl block to render items from
* `krate` - The crate containing item definitions
* `type_renderer` - Type renderer for types
* `process_docs` - Optional closure to process documentation

### `append_docs`

```rust
fn append_docs(md: &mut String, docs: Option<String>)
```

Append processed documentation to markdown.

Helper function to add documentation with consistent formatting.

### `impl_sort_key`

```rust
fn impl_sort_key(impl_block: &rustdoc_types::Impl, type_renderer: &crate::types::TypeRenderer<'_>) -> String
```

**Types:** [`TypeRenderer`](types.md)

Generate a sort key for an impl block for deterministic ordering.

Combines trait name, generic params, and for-type to create a unique key.


=== index.md ===
# Crate `docs_md`

**Version:** 0.1.0

docs-md library interface for testing and reuse.

This module exposes the core functionality of docs-md as a library,
allowing integration tests and external tools to use the markdown
generation capabilities programmatically.

## Modules

- [`error`](error.md) - Error types for docs-md.
- [`generator`](generator.md) - Markdown documentation generator for rustdoc JSON.
- [`linker`](linker.md) - Cross-reference linking for markdown documentation.
- [`multi_crate`](multi_crate.md) - Multi-crate documentation generation.
- [`parser`](parser.md) - Rustdoc JSON parsing module.
- [`types`](types.md) - Type rendering utilities for converting rustdoc types to string representations.

## Structs

### `Args`

```rust
struct Args {
    pub path: Option<std::path::PathBuf>,
    pub dir: Option<std::path::PathBuf>,
    pub mdbook: bool,
    pub search_index: bool,
    pub primary_crate: Option<String>,
    pub output: std::path::PathBuf,
    pub format: CliOutputFormat,
    pub include_private: bool,
    pub include_blanket_impls: bool,
}
```

Command-line arguments for docs-md.

The tool accepts input from two mutually exclusive sources:
1. A local rustdoc JSON file (`--path`)
2. A crate name to fetch from docs.rs (`--crate-name`) - Note: currently non-functional
   as docs.rs doesn't serve rustdoc JSON files publicly.

#### Fields

- **`path`**: `Option<std::path::PathBuf>`

  Path to a local rustdoc JSON file.
  
  Generate this file with: `cargo doc --output-format json`
  The JSON file will be in `target/doc/{crate_name}.json`
  
  Mutually exclusive with `--dir`.

- **`dir`**: `Option<std::path::PathBuf>`

  Directory containing multiple rustdoc JSON files.
  
  Use this for multi-crate documentation generation. The tool will
  scan the directory for all `*.json` files (rustdoc format) and
  generate documentation for each crate with cross-crate linking.
  
  Generate JSON files with:
  `RUSTDOCFLAGS='-Z unstable-options --output-format json' cargo +nightly doc`
  
  Mutually exclusive with `--path`.

- **`mdbook`**: `bool`

  Generate mdBook-compatible SUMMARY.md file.
  
  Only valid with `--dir` for multi-crate documentation.
  Creates a `SUMMARY.md` file in the output directory that can be
  used as the entry point for an mdBook documentation site.

- **`search_index`**: `bool`

  Generate `search_index.json` for client-side search.
  
  Only valid with `--dir` for multi-crate documentation.
  Creates a `search_index.json` file containing all documented items,
  which can be used with client-side search libraries like Fuse.js,
  Lunr.js, or `FlexSearch`.

- **`primary_crate`**: `Option<String>`

  Primary crate name for preferential link resolution.
  
  When specified with `--dir`, links to items in this crate take
  precedence over items with the same name in dependencies.
  This helps resolve ambiguous links like `exit` to the intended
  crate rather than `std::process::exit`.

- **`output`**: `std::path::PathBuf`

  Output directory for generated markdown files.
  
  The directory will be created if it doesn't exist.
  Defaults to `docs/` in the current directory.

- **`format`**: `CliOutputFormat`

  Output format (flat or nested).
  
  - `flat`: All files in one directory (default)
  - `nested`: Directory hierarchy mirroring modules

- **`include_private`**: `bool`

  Include private (non-public) items in the output.
  
  By default, only public items are documented. Enable this
  to also include `pub(crate)`, `pub(super)`, and private items.

- **`include_blanket_impls`**: `bool`

  Include blanket trait implementations in the output.
  
  By default, blanket impls like `From`, `Into`, `TryFrom`, `TryInto`,
  `Any`, `Borrow`, `BorrowMut`, and `ToOwned` are filtered out to reduce
  noise. Enable this to include them in the documentation.

#### Trait Implementations

##### `impl Args for Args`

- `fn group_id() -> Option<clap::Id>`

- `fn augment_args<'b>(__clap_app: clap::Command) -> clap::Command`

- `fn augment_args_for_update<'b>(__clap_app: clap::Command) -> clap::Command`

##### `impl CommandFactory for Args`

- `fn command<'b>() -> clap::Command`

- `fn command_for_update<'b>() -> clap::Command`

##### `impl Debug for Args`

- `fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<'_>) -> $crate::fmt::Result`

##### `impl FromArgMatches for Args`

- `fn from_arg_matches(__clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<Self, clap::Error>`

- `fn from_arg_matches_mut(__clap_arg_matches: &mut clap::ArgMatches) -> ::std::result::Result<Self, clap::Error>`

- `fn update_from_arg_matches(self: &mut Self, __clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<(), clap::Error>`

- `fn update_from_arg_matches_mut(self: &mut Self, __clap_arg_matches: &mut clap::ArgMatches) -> ::std::result::Result<(), clap::Error>`

##### `impl<T> IntoEither for Args`

##### `impl<D> OwoColorize for Args`

##### `impl Parser for Args`

##### `impl<T> Pointable for Args`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`

## Enums

### `OutputFormat`

```rust
enum OutputFormat {
    Flat,
    Nested,
}
```

Output format for the generated markdown documentation.

Controls how module files are organized in the output directory.

#### Variants

- **`Flat`**

  Flat structure: all files in one directory.
  
  Module hierarchy is encoded in filenames using double underscores.
  Example: `parent__child__grandchild.md`

- **`Nested`**

  Nested structure: directories mirror module hierarchy.
  
  Each module gets its own directory with an `index.md` file.
  Example: `parent/child/grandchild/index.md`

#### Trait Implementations

##### `impl Clone for OutputFormat`

- `fn clone(self: &Self) -> OutputFormat` — [`OutputFormat`](#outputformat)

##### `impl Copy for OutputFormat`

##### `impl Debug for OutputFormat`

- `fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<'_>) -> $crate::fmt::Result`

##### `impl Default for OutputFormat`

- `fn default() -> OutputFormat` — [`OutputFormat`](#outputformat)

##### `impl<T> IntoEither for OutputFormat`

##### `impl<D> OwoColorize for OutputFormat`

##### `impl<T> Pointable for OutputFormat`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`

##### `impl ValueEnum for OutputFormat`

- `fn value_variants<'a>() -> &'a [Self]`

- `fn to_possible_value<'a>(self: &Self) -> ::std::option::Option<clap::builder::PossibleValue>`

### `CliOutputFormat`

```rust
enum CliOutputFormat {
    Flat,
    Nested,
}
```

CLI-compatible output format enum (for clap `ValueEnum` derive).

#### Variants

- **`Flat`**

  Flat structure with double-underscore separators in filenames.

- **`Nested`**

  Nested directory structure mirroring the module hierarchy.

#### Trait Implementations

##### `impl Clone for CliOutputFormat`

- `fn clone(self: &Self) -> CliOutputFormat` — [`CliOutputFormat`](#clioutputformat)

##### `impl Copy for CliOutputFormat`

##### `impl Debug for CliOutputFormat`

- `fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<'_>) -> $crate::fmt::Result`

##### `impl Default for CliOutputFormat`

- `fn default() -> CliOutputFormat` — [`CliOutputFormat`](#clioutputformat)

##### `impl<T> IntoEither for CliOutputFormat`

##### `impl<D> OwoColorize for CliOutputFormat`

##### `impl<T> Pointable for CliOutputFormat`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`

##### `impl ValueEnum for CliOutputFormat`

- `fn value_variants<'a>() -> &'a [Self]`

- `fn to_possible_value<'a>(self: &Self) -> ::std::option::Option<clap::builder::PossibleValue>`


=== linker.md ===
# Module `linker`

Cross-reference linking for markdown documentation.

This module provides the `LinkRegistry` which maps rustdoc item IDs to their
corresponding markdown file paths. This enables creating clickable links
between items in the generated documentation.

# How It Works

1. During initialization, `LinkRegistry::build()` traverses the entire crate
   and records where each item's documentation will be written.

2. During markdown generation, `create_link()` is called to generate
   relative links from one file to another.

# Path Formats

The registry supports two output formats:

- **Flat**: `module.md`, `parent__child.md` (double-underscore separators)
- **Nested**: `module/index.md`, `parent/child/index.md` (directory structure)

# Example

```ignore
let registry = LinkRegistry::build(&krate, true); // flat format
let link = registry.create_link(&some_id, "index.md");
// Returns: Some("[`ItemName`](module.md)")
```

## Structs

### `LinkRegistry`

```rust
struct LinkRegistry {
    item_paths: std::collections::HashMap<rustdoc_types::Id, String>,
    item_names: std::collections::HashMap<rustdoc_types::Id, String>,
}
```

Registry mapping item IDs to their documentation file paths.

This is the central data structure for cross-reference resolution.
It's built once during generation and queried whenever we need to
create links between items.

#### Fields

- **`item_paths`**: `std::collections::HashMap<rustdoc_types::Id, String>`

  Maps each item's ID to the markdown file path where it's documented.
  
  Paths are relative to the output directory root.
  Examples: `"index.md"`, `"span.md"`, `"span/index.md"`

- **`item_names`**: `std::collections::HashMap<rustdoc_types::Id, String>`

  Maps each item's ID to its display name.
  
  Used to generate the link text (e.g., `[`name`](path)`).
  This is typically the item's identifier without the full path.

#### Implementations

- `fn build(krate: &Crate, flat_format: bool) -> Self`

  Build a link registry by traversing all items in the crate.

- `fn register_module_items(self: &mut Self, krate: &Crate, module_id: Id, module_item: &rustdoc_types::Item, path: &str, module_prefix: &str, flat_format: bool)`

  Recursively register all items within a module.

- `fn get_path(self: &Self, id: Id) -> Option<&String>`

  Get the file path where an item is documented.

- `fn get_name(self: &Self, id: Id) -> Option<&String>`

  Get the display name for an item.

- `fn create_link(self: &Self, id: Id, from_path: &str) -> Option<String>`

  Create a markdown link to an item from a given source file.

- `fn compute_relative_path(from: &str, to: &str) -> String`

  Compute the relative path from one file to another.

#### Trait Implementations

##### `impl Debug for LinkRegistry`

- `fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<'_>) -> $crate::fmt::Result`

##### `impl Default for LinkRegistry`

- `fn default() -> LinkRegistry` — [`LinkRegistry`](#linkregistry)

##### `impl<T> IntoEither for LinkRegistry`

##### `impl<D> OwoColorize for LinkRegistry`

##### `impl<T> Pointable for LinkRegistry`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`

## Functions

### `slugify_anchor`

```rust
fn slugify_anchor(name: &str) -> String
```

Convert a name to a GitHub-style markdown anchor slug.

This normalizes item names to match the anchor IDs generated by markdown
renderers (GitHub, mdBook, etc.) when they process headings.

# Rules Applied

1. Apply Unicode NFC normalization (canonical composition)
2. Convert to lowercase (full Unicode, not just ASCII)
3. Remove backticks (markdown code formatting)
4. Remove generics (`<T>`, `<K, V>`) by stripping `<...>` content
5. Replace spaces and underscores with hyphens
6. Remove non-alphanumeric characters (except hyphens)
7. Collapse consecutive hyphens
8. Trim leading/trailing hyphens

# Examples

```ignore
assert_eq!(slugify_anchor("HashMap"), "hashmap");
assert_eq!(slugify_anchor("HashMap<K, V>"), "hashmap");
assert_eq!(slugify_anchor("my_function"), "my-function");
assert_eq!(slugify_anchor("Into<T>"), "into");
assert_eq!(slugify_anchor("Größe"), "größe");
```


=== multi_crate.md ===
# Module `multi_crate`

Multi-crate documentation generation.

This module provides support for generating documentation from multiple
rustdoc JSON files, enabling cross-crate linking and self-contained
documentation for entire dependency trees.

# Architecture

The multi-crate system uses these components:

- [`CrateCollection`](multi_crate__collection.md): Container for parsed crates with processing order
- [`MultiCrateParser`](multi_crate__parser.md): Scans directories and parses JSON files
- [`UnifiedLinkRegistry`](multi_crate__registry.md): Cross-crate link resolution
- [`MultiCrateContext`](multi_crate__context.md): Shared state during generation
- [`MultiCrateGenerator`](multi_crate__generator.md): Orchestrates per-crate generation
- [`SummaryGenerator`](multi_crate__summary.md): Creates mdBook-compatible SUMMARY.md

# Usage

```ignore
use docs_md::multi_crate::{MultiCrateParser, MultiCrateGenerator};

let crates = MultiCrateParser::parse_directory(Path::new("target/doc"))?;
let generator = MultiCrateGenerator::new(&crates, &args);
generator.generate()?;
```


=== parser.md ===
# Module `parser`

Rustdoc JSON parsing module.

This module handles loading and parsing rustdoc JSON files into the
`rustdoc_types::Crate` structure that represents the entire documented crate.

# Rustdoc JSON Format

Rustdoc JSON is generated by running:
```bash
cargo doc --output-format json
```

The output is a single JSON file at `target/doc/{crate_name}.json` containing:
- The crate's module hierarchy
- All public (and optionally private) items
- Documentation strings
- Type information and generics
- Cross-reference links between items

# Key Types

The parsed `Crate` contains:
- `root`: ID of the root module
- `index`: `HashMap` of all items by their ID
- `paths`: `HashMap` mapping IDs to their full module paths
- `crate_version`: Optional version string

# Performance

When the `simd-json` feature is enabled, parsing uses SIMD-accelerated
JSON parsing which is significantly faster for large rustdoc JSON files
(10-50MB+). This requires AVX2/SSE4.2 on x86 platforms.

## Structs

### `Parser`

```rust
struct Parser;
```

Parser for rustdoc JSON files.

Provides methods to load and parse rustdoc JSON from files or strings
into the `rustdoc_types::Crate` structure.

#### Implementations

- `fn parse_json(path: &Path) -> Result<Crate, Error>` — [`Error`](error.md)

  Parse a rustdoc JSON file from disk into a `Crate` structure.

- `fn parse_json_string(content: &str) -> Result<Crate, Error>` — [`Error`](error.md)

  Parse a rustdoc JSON string into a `Crate` structure.

#### Trait Implementations

##### `impl<T> IntoEither for Parser`

##### `impl<D> OwoColorize for Parser`

##### `impl<T> Pointable for Parser`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`


=== types.md ===
# Module `types`

Type rendering utilities for converting rustdoc types to string representations.

This module provides the [`TypeRenderer`](#typerenderer) struct to convert the complex type
structures from rustdoc JSON into human-readable Rust type syntax. These
rendered strings are used in the generated markdown documentation.

# Overview

Rustdoc JSON represents types as a tree structure (the `Type` enum). The
[`TypeRenderer`](#typerenderer) walks that tree and produces the string representation
you'd write in code.

# Usage

```ignore
let renderer = TypeRenderer::new(&krate);
let type_string = renderer.render_type(&some_type);
let generics = renderer.render_generics(&generic_params);
```

# Example Transformations

| Rustdoc Type | Rendered String |
|--------------|-----------------|
| `Type::Primitive("u32")` | `"u32"` |
| `Type::BorrowedRef { lifetime: Some("'a"), is_mutable: true, type_: ... }` | `"&'a mut T"` |
| `Type::ResolvedPath { path: "Vec", args: ... }` | `"Vec<T>"` |

# Performance

Uses `Cow<str>` to avoid allocations for simple types like primitives,
generics, and inferred types. Complex types that require string building
return owned strings.

## Structs

### `TypeRenderer<'a>`

```rust
struct TypeRenderer<'a> {
    krate: &'a rustdoc_types::Crate,
}
```

Type renderer for converting rustdoc types to Rust syntax strings.

This struct holds a reference to the crate context and provides methods
to render various type constructs into their string representations.

# Design Note

The `krate` field is currently unused because the `Type` enum is self-contained.
However, it is retained for:
- **Future-proofing**: May need to look up items in `krate.index` for enhanced rendering
- **API consistency**: Signals that the renderer is bound to a specific crate context
- **Type safety**: Prevents accidentally mixing renderers across different crates

# Example

```ignore
let renderer = TypeRenderer::new(&krate);
let type_str = renderer.render_type(&some_type);
let generics = renderer.render_generics(&params);
```

#### Fields

- **`krate`**: `&'a rustdoc_types::Crate`

  Reference to the crate for looking up type information.
  
  Reserved for future use (e.g., resolving paths, getting item metadata).

#### Implementations

- `const fn new(krate: &'a Crate) -> Self`

  Create a new type renderer with the given crate context.

- `fn render_type<'t>(self: &Self, ty: &'t Type) -> Cow<'t, str>`

  Render a rustdoc `Type` to its Rust syntax string representation.

- `fn render_generic_args(self: &Self, args: &GenericArgs) -> String`

  Render generic arguments in angle bracket or parenthesized form.

- `fn render_generic_arg<'t>(self: &Self, arg: &'t GenericArg) -> Cow<'t, str>`

  Render a single generic argument.

- `fn render_assoc_item_constraint(self: &Self, constraint: &AssocItemConstraint) -> String`

  Render an associated type constraint.

- `fn render_term<'t>(self: &Self, term: &'t Term) -> Cow<'t, str>`

  Render a term, which is either a type or a constant.

- `fn render_generic_bound<'t>(self: &Self, bound: &'t GenericBound) -> Cow<'t, str>`

  Render a generic bound (trait bound or lifetime bound).

- `fn render_generics(self: &Self, generics: &[GenericParamDef]) -> String`

  Render a list of generic parameter definitions.

- `fn render_generic_param_def(self: &Self, param: &GenericParamDef) -> Option<String>`

  Render a single generic parameter definition.

- `fn render_where_clause(self: &Self, where_predicates: &[rustdoc_types::WherePredicate]) -> String`

  Render where clause predicates.

- `fn render_where_predicate(self: &Self, pred: &rustdoc_types::WherePredicate) -> String`

  Render a single where predicate.

- `fn collect_linkable_types(self: &Self, ty: &Type) -> Vec<(String, rustdoc_types::Id)>`

  Collect all linkable type names from a type.

- `fn collect_types_recursive(self: &Self, ty: &Type, result: &mut Vec<(String, rustdoc_types::Id)>)`

  Recursively collect linkable types from a type tree.

- `fn collect_from_generic_args(self: &Self, args: &GenericArgs, result: &mut Vec<(String, rustdoc_types::Id)>)`

  Collect types from generic arguments.

#### Trait Implementations

##### `impl<'a> Clone for TypeRenderer<'a>`

- `fn clone(self: &Self) -> TypeRenderer<'a>` — [`TypeRenderer`](#typerenderer)

##### `impl<'a> Copy for TypeRenderer<'a>`

##### `impl<'a> Debug for TypeRenderer<'a>`

- `fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<'_>) -> $crate::fmt::Result`

##### `impl<T> IntoEither for TypeRenderer<'a>`

##### `impl<D> OwoColorize for TypeRenderer<'a>`

##### `impl<T> Pointable for TypeRenderer<'a>`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`
