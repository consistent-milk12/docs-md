*[docs_md](../index.md) / [linker](index.md)*

---

# Module `linker`

Cross-reference linking for markdown documentation.

This module provides the `LinkRegistry` which maps rustdoc item IDs to their
corresponding markdown file paths. This enables creating clickable links
between items in the generated documentation.

# How It Works

1. During initialization, `LinkRegistry::build()` traverses the entire crate
   and records where each item's documentation will be written.

2. During markdown generation, `create_link()` is called to generate
   relative links from one file to another.

# Path Formats

The registry supports two output formats:

- **Flat**: `module.md`, `parent__child.md` (double-underscore separators)
- **Nested**: `module/index.md`, `parent/child/index.md` (directory structure)

# Example

```ignore
let registry = LinkRegistry::build(&krate, true); // flat format
let link = registry.create_link(&some_id, "index.md");
// Returns: Some("[`ItemName`](module.md)")
```

## Structs

### `LinkRegistry`

```rust
struct LinkRegistry {
    item_paths: std::collections::HashMap<rustdoc_types::Id, String>,
    item_names: std::collections::HashMap<rustdoc_types::Id, String>,
}
```

Registry mapping item IDs to their documentation file paths.

This is the central data structure for cross-reference resolution.
It's built once during generation and queried whenever we need to
create links between items.

#### Fields

- **`item_paths`**: `std::collections::HashMap<rustdoc_types::Id, String>`

  Maps each item's ID to the markdown file path where it's documented.
  
  Paths are relative to the output directory root.
  Examples: `"index.md"`, `"span.md"`, `"span/index.md"`

- **`item_names`**: `std::collections::HashMap<rustdoc_types::Id, String>`

  Maps each item's ID to its display name.
  
  Used to generate the link text (e.g., `[`name`](path)`).
  This is typically the item's identifier without the full path.

#### Implementations

- `fn build(krate: &Crate, flat_format: bool, include_private: bool) -> Self`

- `fn register_module_items(self: &mut Self, krate: &Crate, module_id: Id, module_item: &rustdoc_types::Item, path: &str, module_prefix: &str, flat_format: bool, include_private: bool)`

- `fn register_glob_items(self: &mut Self, krate: &Crate, use_item: &rustdoc_types::Use, path: &str, include_private: bool)`

- `fn get_path(self: &Self, id: Id) -> Option<&String>`

- `fn get_name(self: &Self, id: Id) -> Option<&String>`

- `fn create_link(self: &Self, id: Id, from_path: &str) -> Option<String>`

- `fn compute_relative_path(from: &str, to: &str) -> String`

#### Trait Implementations

##### `impl Debug for LinkRegistry`

- `fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<'_>) -> $crate::fmt::Result`

##### `impl Default for LinkRegistry`

- `fn default() -> LinkRegistry` — [`LinkRegistry`](#linkregistry)

##### `impl<T> IntoEither for LinkRegistry`

##### `impl<D> OwoColorize for LinkRegistry`

##### `impl<T> Pointable for LinkRegistry`

- `const ALIGN: usize`

- `type Init = T`

- `unsafe fn init(init: <T as Pointable>::Init) -> usize`

- `unsafe fn deref<'a>(ptr: usize) -> &'a T`

- `unsafe fn deref_mut<'a>(ptr: usize) -> &'a mut T`

- `unsafe fn drop(ptr: usize)`

## Functions

### `slugify_anchor`

```rust
fn slugify_anchor(name: &str) -> String
```

Convert a name to a GitHub-style markdown anchor slug.

This normalizes item names to match the anchor IDs generated by markdown
renderers (GitHub, mdBook, etc.) when they process headings.

# Rules Applied

1. Apply Unicode NFC normalization (canonical composition)
2. Convert to lowercase (full Unicode, not just ASCII)
3. Remove backticks (markdown code formatting)
4. Remove generics (`<T>`, `<K, V>`) by stripping `<...>` content
5. Replace spaces and underscores with hyphens
6. Remove non-alphanumeric characters (except hyphens)
7. Collapse consecutive hyphens
8. Trim leading/trailing hyphens

# Examples

```ignore
assert_eq!(slugify_anchor("HashMap"), "hashmap");
assert_eq!(slugify_anchor("HashMap<K, V>"), "hashmap");
assert_eq!(slugify_anchor("my_function"), "my-function");
assert_eq!(slugify_anchor("Into<T>"), "into");
assert_eq!(slugify_anchor("Größe"), "größe");
```

