*[unicode_width](../index.md) / [tables](index.md)*

---

# Module `tables`

## Structs

### `WidthInfo`

```rust
struct WidthInfo(u16);
```

#### Implementations

- `const DEFAULT: Self`

- `const LINE_FEED: Self`

- `const EMOJI_MODIFIER: Self`

- `const REGIONAL_INDICATOR: Self`

- `const SEVERAL_REGIONAL_INDICATOR: Self`

- `const EMOJI_PRESENTATION: Self`

- `const ZWJ_EMOJI_PRESENTATION: Self`

- `const VS16_ZWJ_EMOJI_PRESENTATION: Self`

- `const KEYCAP_ZWJ_EMOJI_PRESENTATION: Self`

- `const VS16_KEYCAP_ZWJ_EMOJI_PRESENTATION: Self`

- `const REGIONAL_INDICATOR_ZWJ_PRESENTATION: Self`

- `const EVEN_REGIONAL_INDICATOR_ZWJ_PRESENTATION: Self`

- `const ODD_REGIONAL_INDICATOR_ZWJ_PRESENTATION: Self`

- `const TAG_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const TAG_D1_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const TAG_D2_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const TAG_D3_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const TAG_A1_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const TAG_A2_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const TAG_A3_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const TAG_A4_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const TAG_A5_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const TAG_A6_END_ZWJ_EMOJI_PRESENTATION: Self`

- `const KIRAT_RAI_VOWEL_SIGN_E: Self`

- `const KIRAT_RAI_VOWEL_SIGN_AI: Self`

- `const VARIATION_SELECTOR_1_2_OR_3: Self`

- `const VARIATION_SELECTOR_15: Self`

- `const VARIATION_SELECTOR_16: Self`

- `const JOINING_GROUP_ALEF: Self`

- `const COMBINING_LONG_SOLIDUS_OVERLAY: Self`

- `const SOLIDUS_OVERLAY_ALEF: Self`

- `const HEBREW_LETTER_LAMED: Self`

- `const ZWJ_HEBREW_LETTER_LAMED: Self`

- `const BUGINESE_LETTER_YA: Self`

- `const ZWJ_BUGINESE_LETTER_YA: Self`

- `const BUGINESE_VOWEL_SIGN_I_ZWJ_LETTER_YA: Self`

- `const TIFINAGH_CONSONANT: Self`

- `const ZWJ_TIFINAGH_CONSONANT: Self`

- `const TIFINAGH_JOINER_CONSONANT: Self`

- `const LISU_TONE_LETTER_MYA_NA_JEU: Self`

- `const OLD_TURKIC_LETTER_ORKHON_I: Self`

- `const ZWJ_OLD_TURKIC_LETTER_ORKHON_I: Self`

- `const KHMER_COENG_ELIGIBLE_LETTER: Self`

- `fn is_ligature_transparent(self: Self) -> bool`

- `fn set_zwj_bit(self: Self) -> Self`

- `fn is_emoji_presentation(self: Self) -> bool`

- `fn is_zwj_emoji_presentation(self: Self) -> bool`

- `fn set_emoji_presentation(self: Self) -> Self`

- `fn unset_emoji_presentation(self: Self) -> Self`

- `fn is_text_presentation(self: Self) -> bool`

- `fn set_text_presentation(self: Self) -> Self`

- `fn unset_text_presentation(self: Self) -> Self`

- `fn is_vs1_2_3(self: Self) -> bool`

- `fn set_vs1_2_3(self: Self) -> Self`

- `fn unset_vs1_2_3(self: Self) -> Self`

#### Trait Implementations

##### `impl Clone for WidthInfo`

- `fn clone(self: &Self) -> WidthInfo` — [`WidthInfo`](#widthinfo)

##### `impl Copy for WidthInfo`

##### `impl Debug for WidthInfo`

- `fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<'_>) -> $crate::fmt::Result`

##### `impl Eq for WidthInfo`

##### `impl PartialEq for WidthInfo`

- `fn eq(self: &Self, other: &WidthInfo) -> bool` — [`WidthInfo`](#widthinfo)

##### `impl<T> Sealed for WidthInfo`

##### `impl StructuralPartialEq for WidthInfo`

### `Align32<T>`

```rust
struct Align32<T>(T);
```

#### Trait Implementations

##### `impl<T> Sealed for Align32<T>`

### `Align64<T>`

```rust
struct Align64<T>(T);
```

#### Trait Implementations

##### `impl<T> Sealed for Align64<T>`

### `Align128<T>`

```rust
struct Align128<T>(T);
```

#### Trait Implementations

##### `impl<T> Sealed for Align128<T>`

## Functions

### `lookup_width`

```rust
fn lookup_width(c: char) -> (u8, WidthInfo)
```

Returns the [UAX #11](https://www.unicode.org/reports/tr11/) based width of `c` by
consulting a multi-level lookup table.

# Maintenance
The tables themselves are autogenerated but this function is hardcoded. You should have
nothing to worry about if you re-run `unicode.py` (for example, when updating Unicode.)
However, if you change the *actual structure* of the lookup tables (perhaps by editing the
`make_tables` function in `unicode.py`) you must ensure that this code reflects those changes.

### `single_char_width`

```rust
fn single_char_width(c: char) -> Option<usize>
```

Returns the [UAX #11](https://www.unicode.org/reports/tr11/) based width of `c`, or
`None` if `c` is a control character.
Ambiguous width characters are treated as narrow.

### `width_in_str`

```rust
fn width_in_str(c: char, next_info: WidthInfo) -> (i8, WidthInfo)
```

Returns the [UAX #11](https://www.unicode.org/reports/tr11/) based width of `c`.
Ambiguous width characters are treated as narrow.

### `str_width`

```rust
fn str_width(s: &str) -> usize
```

### `lookup_width_cjk`

```rust
fn lookup_width_cjk(c: char) -> (u8, WidthInfo)
```

Returns the [UAX #11](https://www.unicode.org/reports/tr11/) based width of `c` by
consulting a multi-level lookup table.

# Maintenance
The tables themselves are autogenerated but this function is hardcoded. You should have
nothing to worry about if you re-run `unicode.py` (for example, when updating Unicode.)
However, if you change the *actual structure* of the lookup tables (perhaps by editing the
`make_tables` function in `unicode.py`) you must ensure that this code reflects those changes.

### `single_char_width_cjk`

```rust
fn single_char_width_cjk(c: char) -> Option<usize>
```

Returns the [UAX #11](https://www.unicode.org/reports/tr11/) based width of `c`, or
`None` if `c` is a control character.
Ambiguous width characters are treated as wide.

### `width_in_str_cjk`

```rust
fn width_in_str_cjk(c: char, next_info: WidthInfo) -> (i8, WidthInfo)
```

Returns the [UAX #11](https://www.unicode.org/reports/tr11/) based width of `c`.
Ambiguous width characters are treated as wide.

### `str_width_cjk`

```rust
fn str_width_cjk(s: &str) -> usize
```

### `is_transparent_zero_width`

```rust
fn is_transparent_zero_width(c: char) -> bool
```

Whether this character is a zero-width character with
`Joining_Type=Transparent`. Used by the Alef-Lamed ligatures.
See also [`is_ligature_transparent`](#is-ligature-transparent), a near-subset of this (only ZWJ is excepted)
which is transparent for non-Arabic ligatures.

### `is_ligature_transparent`

```rust
fn is_ligature_transparent(c: char) -> bool
```

Whether this character is a default-ignorable combining mark
or ZWJ. These characters won't interrupt non-Arabic ligatures.

### `is_solidus_transparent`

```rust
fn is_solidus_transparent(c: char) -> bool
```

Whether this character is transparent wrt the effect of
U+0338 COMBINING LONG SOLIDUS OVERLAY
on its base character.

### `starts_emoji_presentation_seq`

```rust
fn starts_emoji_presentation_seq(c: char) -> bool
```

Whether this character forms an [emoji presentation sequence]
(https://www.unicode.org/reports/tr51/#def_emoji_presentation_sequence)
when followed by `'\u{FEOF}'`.
Emoji presentation sequences are considered to have width 2.

### `starts_non_ideographic_text_presentation_seq`

```rust
fn starts_non_ideographic_text_presentation_seq(c: char) -> bool
```

Returns `true` if `c` has default emoji presentation, but forms a [text presentation sequence]
(https://www.unicode.org/reports/tr51/#def_text_presentation_sequence)
when followed by `'\u{FEOE}'`, and is not ideographic.
Such sequences are considered to have width 1.

### `is_emoji_modifier_base`

```rust
fn is_emoji_modifier_base(c: char) -> bool
```

Returns `true` if `c` is an `Emoji_Modifier_Base`.

## Constants

### `LIGATURE_TRANSPARENT_MASK`

```rust
const LIGATURE_TRANSPARENT_MASK: u16 = 8_192u16;
```

### `UNICODE_VERSION`

```rust
const UNICODE_VERSION: (u8, u8, u8);
```

The version of [Unicode](http://www.unicode.org/)
that this version of unicode-width is based on.

### `WIDTH_MIDDLE_LEN`

```rust
const WIDTH_MIDDLE_LEN: usize = 20usize;
```

### `WIDTH_LEAVES_LEN`

```rust
const WIDTH_LEAVES_LEN: usize = 186usize;
```

